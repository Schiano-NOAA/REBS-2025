<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>management</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="05_management_files/libs/clipboard/clipboard.min.js"></script>
<script src="05_management_files/libs/quarto-html/quarto.js"></script>
<script src="05_management_files/libs/quarto-html/popper.min.js"></script>
<script src="05_management_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="05_management_files/libs/quarto-html/anchor.min.js"></script>
<link href="05_management_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="05_management_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="05_management_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="05_management_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="05_management_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="management" class="level1">
<h1>Management</h1>
<section id="reference-points" class="level2">
<h2 class="anchored" data-anchor-id="reference-points">Reference Points</h2>
<p>Reference points were calculated using the estimated fishery selectivity and removals in the most recent year of the model (2024, <strong>?@tbl-man-ref-points</strong>). Reference points were based on the rockfish <span class="math inline">\(\text{F}_{MSY\%}\)</span> proxy (<span class="math inline">\(\text{SPR}_{50\%}\)</span>), target relative biomass (40%), and estimated selectivity and catch for each fleet (<strong>?@tbl-man-ref-points</strong>). The proxy MSY values of management quantities are by definition more conservative compared to the estimated MSY and MSY relative to 40% of unfished spawning output because of the assumed steepness value. Sustainable total yield, removals, using the proxy <span class="math inline">\(\text{SPR}_{50\%}\)</span> is <code>r round(model_output$derived_quants[model_output$derived_quants$Label == 'Dead_Catch_SPR', 'Value'], 2)</code> mt. The spawning output equivalent to 40% of the unfished spawning output (<span class="math inline">\(\text{SO}_{40\%}\)</span>) calculated using the SPR target (<span class="math inline">\(\text{SPR}_{50\%}\)</span>) was <code>r round(model_output$derived_quants[model_output$derived_quants$Label == 'SSB_SPR', 'Value'], 2)</code> millions of eggs.</p>
<p>The 2025 spawning biomass relative to unfished equilibrium spawning biomass, based on the 2024 fishing year, is <code>r 100*(round(model_output$derived_quants[model_output$derived_quants$Label == 'Bratio_2025', 'Value'], 2))</code>%, above the management target of 40% of unfished spawning output (<strong>?@fig-management-depletion</strong>). The fishing intensity, <span class="math inline">\(1-SPR\)</span>, was below or just slightly above harvest rate limit (<span class="math inline">\(SPR_{50\%}\)</span>) from the mid-1980s through the 1990s. Removals since 2000 have been below the point estimate of potential long-term yields calculated using an <span class="math inline">\(\text{SPR}_{50\%}\)</span> reference point (<strong>?@tbl-man-timeseries</strong> and <strong>?@fig-one-minus-spr</strong>). The equilibrium estimates of yield relative to biomass based on a steepness value fixed at <code>r round(model_output$parameters[model_output$parameters$Label == "SR_BH_steep","Value"], 2)</code> are provided in <strong>?@fig-management-yield</strong>, where vertical dashed lines indicate the estimate of fraction unfished at the start of 2025 (current) and the estimated management targets calculated based on the relative target biomass (B target), the SPR target, and the maximum sustainable yield (MSY).</p>
<p>The relative biomass and the ratio of the estimated SPR to the management target (<span class="math inline">\(\text{SPR}_{50\%}\)</span>) across all model years are shown in <strong>?@fig-management-phase</strong> where cooler colors (purple) represent early years and warmer colors (yellow) represent recent years. The stock staus has not decreased below the target relative biomass, and fishing intensity (except for in 1995) has been below the target fishing intensity based on <span class="math inline">\(\text{SPR}_{50\%}\)</span>.</p>
</section>
<section id="management-performance" class="level2">
<h2 class="anchored" data-anchor-id="management-performance">Management performance</h2>
<p>In the last ten years total dead catches of <code>r Spp</code> have been below the annual catch limit. The last ten years total dead catches for <code>r Spp</code> against he overfishing limits (OFLs), the acceptable biological catches (ABCs), the annual catch limits (ACLs) are shown in <strong>?@tbl-man-management</strong>.</p>
</section>
<section id="harvest-projections-and-decision-tables" class="level2">
<h2 class="anchored" data-anchor-id="harvest-projections-and-decision-tables">Harvest Projections and Decision Tables</h2>
<p>The <code>r Spp</code> assessment is being considered as a category 1 assessment with a <span class="math inline">\(P^*\)</span> = 0.45, <span class="math inline">\(\sigma\)</span> = 0.68 (estimated within the model, see <a href="#sec-uncertainty" class="quarto-xref">Section&nbsp;1.4</a>) and a time-varying buffer applied to set the ABC below the OFL. These multipliers are also combined with the rockfish MSY proxy of SPR and the 40-10 harvest control rule to calculate OFLs and ACLs. Projections of the overfishing limit, acceptable biological catch, and annual catch limit, all based on a <span class="math inline">\(P^*\)</span> of 0.45 and a log-space standard deviation of the overfishing limit (<span class="math inline">\(\sigma\)</span>) of 0.50 are included in <strong>?@tbl-man-projections</strong>. Assumed catches for 2025 and 2026 for this projection were provided by the PFMC Groundfish Management Team, and catches from 2027 onward assume full attainment of the acceptable biological catch.</p>
<p>No decision table needed in draft assessments undergoing review.</p>
</section>
<section id="sec-uncertainty" class="level2">
<h2 class="anchored" data-anchor-id="sec-uncertainty">Evaluation of Scientific Uncertainty</h2>
<p>The model estimated uncertainty around the 2025 spawning output for is <span class="math inline">\(\sigma\)</span> = 0.6836465. The uncertainty around the OFL is<span class="math inline">\(\sigma\)</span> = 0.6713586. These <span class="math inline">\(\sigma\)</span> values underestimate the overall uncertainty as they do not incorporate the model structural uncertainty and do not account for any time-varying dynamics other than recruitment. The estimated uncertainty values are higher than the Category 1 default <span class="math inline">\(\sigma\)</span> = 0.5, so all projections will use the estimated <span class="math inline">\(\sigma\)</span>. The alternative states of nature used to bracket uncertainty in the decision table assist with encapsulating model structure uncertainty.</p>
</section>
<section id="research-and-data-needs" class="level2">
<h2 class="anchored" data-anchor-id="research-and-data-needs">Research and Data Needs</h2>
<p>There are many areas of research that could be improved to benefit the understanding and assessment of <code>r Spp</code>. Below, we identify several of them that we consider particularly important.</p>
<ul>
<li><p>Understanding the stock structure and biology of Rougheye and Blackspotted Rockfishes: This assessment reports the status of <code>r Spp</code> as a pooled complex because it is extremely difficult to separate the catches of each species even in recent data, and attempting to do so would greatly increase the uncertainty in the predictions. Because little is known about the respective biology and catch histories of the two species, it is unclear whether managing them as a complex may place one species at disproportionate risk of overfishing relative to the other. Additional research that will provide insight into the distribution, life history, biological characteristics, and catch and discard profiles of the two species is recommended. Such an endeavor would like require the efforts of at sea observers in all fleets, biologists aboard fishery-independent surveys, and port samplers along the entire West Coast requiring broad, inter-agency collaboration.</p></li>
<li><p>Understanding of coatwide stock structure, connectivity, and distribution: This is a stock assessment for <code>r Spp</code> off of the west coast of the U.S. and does not consider data from British Columbia or Alaska. Further investigating and comparing the data and predictions from British Columbia and Alaska to determine if there are similarities with the U.S. West Coast observations would help to define the connectivity between rougheye rockfish north of the U.S.-Canada border.</p></li>
<li><p>Natural mortality: Uncertainty in natural mortality translates into uncertain estimates of status and sustainable fishing levels for <code>r Spp</code>. <code>r spp</code> are one of the longest lived species of rockfish (with maximum age as old as 205 years reported in the literature). Assessment model was able to estimate female natural mortality, consistent with maximum age based meta-analytical prior, but with male natural mortality fixed at the median of the prior. The collection of additional age data and further research of the life-history of <code>r Spp</code> may improve our understanding of <code>r Spp</code> natural mortality.</p></li>
<li><p>Historical landings and discards, including investigation of fisheries selectivity: The substantial progress has been made in reconstructing historical landings of rockfishes on the U.S. West Coast, including those for <code>r Spp</code>. This assessment highlighted the importance of understanding of fishery selectivity assumptions associated with removals and how fishery selectivity changes throughout the years. Further understanding of this area would help reduce uncertainty in estimated scale of the stock.</p></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>